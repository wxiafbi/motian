/*-------------------------------------------------*/
/*            超纬电子STM32系列开发板              */
/*-------------------------------------------------*/
/*                                                 */
/*          实现各种中断服务函数的源文件           */
/*                                                 */
/*-------------------------------------------------*/

#include "stm32f10x.h"    //包含需要的头文件
#include "stm32f10x_it.h" //包含需要的头文件
#include "main.h"         //包含需要的头文件
#include "delay.h"        //包含需要的头文件
#include "usart1.h"       //包含需要的头文件
#include "usart3.h"       //包含需要的头文件
#include "timer4.h"       //包含需要的头文件
#include "cat1.h"         //包含需要的头文件
#include "timer3.h"       //包含需要的头文件
#include "led.h"          //包含需要的头文件
#include "mqtt.h"         //包含需要的头文件
#include "usart9.h"       //包含需要的头文件
#include "exti.h"
#include "stmflash.h"
#include "oled.h"
#include "beep.h"

char fina_data1[5];
char fina_data2[5];
int finaldata1;
int finaldata2;

/*-------------------------------------------------*/
/*函数名：串口3接收中断函数                        */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void USART2_IRQHandler(void)
{
    if ((USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)) { // 如果USART_IT_RXNE标志置位，表示有数据到了 进入if分支
        if (USART2->DR) {                                      // 处于指令配置状态时，非零值才保存到缓冲区
            Usart2_RxBuff[Usart2_RxCounter] = USART2->DR;      // 保存到缓冲区
            Usart2_RxCounter++;                                // 每接收1个字节的数据，Usart3_RxCounter加1，表示接收的数据总量+1
        }
    }
    if ((USART_GetITStatus(USART2, USART_IT_IDLE) != RESET)) {                         // 如USART_IT_IDLE标志置位，表示空闲中断 进入if分支
        Usart2_RxCounter = USART2->SR;                                                 // 清除USART_IT_IDLE标志  步骤1
        Usart2_RxCounter = USART2->DR;                                                 // 清除USART_IT_IDLE标志  步骤2
        DMA_Cmd(DMA1_Channel6, DISABLE);                                               // 关闭DMA
        Usart2_RxCounter = USART2_RXBUFF_SIZE - DMA_GetCurrDataCounter(DMA1_Channel6); // 获取串口接收的数据量
        memcpy(&MQTT_RxDataInPtr[2], Usart2_RxBuff, Usart2_RxCounter);                 // 拷贝数据到接收缓冲区
        MQTT_RxDataInPtr[0] = Usart2_RxCounter / 256;                                  // 记录数据长度高字节
        MQTT_RxDataInPtr[1] = Usart2_RxCounter % 256;                                  // 记录数据长度低字节
        MQTT_RxDataInPtr += RBUFF_UNIT;                                                // 指针下移
        if (MQTT_RxDataInPtr == MQTT_RxDataEndPtr)                                     // 如果指针到缓冲区尾部了
            MQTT_RxDataInPtr = MQTT_RxDataBuf[0];                                      // 指针归位到缓冲区开头
        Usart2_RxCounter     = 0;                                                      // 串口3接收数据量变量清零
        DMA1_Channel6->CNDTR = USART2_RXBUFF_SIZE;                                     // 重新设置接收数据个数
        DMA_Cmd(DMA1_Channel6, ENABLE);                                                // 开启DMA
        TIM_SetCounter(TIM3, 0);                                                       // 清除定时器3 计数值
    }
}
/*-------------------------------------------------*/
/*函数名：串口2接收中断函数                        */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void USART3_IRQHandler(void)
{
    static u8 seri_count = 0;
    char check_flag, end_flag, j, k = 0;
    u8 x;

    static u8 uflag = 0;
    if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) //?????
    {

        if (USART_ReceiveData(USART3) == 0x44) {
            uflag = 1;
        }
        if (uflag) {
            USART3_RX_BUF[seri_count++] = USART_ReceiveData(USART3);
            if (USART_ReceiveData(USART3) == 0x0A) {
                beep_on_200ms();
                for (size_t i = 0; i < seri_count; i++) {
                    /* code */
                    u1_printf("%x ", USART3_RX_BUF[i]);
                    switch (USART3_RX_BUF[i]) {
                        case 0x6D:
                            check_flag = i;
                            u1_printf("0x6D在第%d位", check_flag);
                            break;
                        case 0x23:
                            end_flag = i;
                            u1_printf("0x0D在第%d位", end_flag);
                            break;
                        default:
                            break;
                    }
                }
                for (size_t i = 2; i < check_flag; i++) {
                    if (USART3_RX_BUF[i] == 0x2E) {
                        continue;
                    }
                    fina_data1[j++] = USART3_RX_BUF[i];
                }
                for (size_t a = check_flag + 1; a < end_flag; a++) {
                    if (USART3_RX_BUF[a] == 0x2C) {
                        continue;
                    }
                    fina_data2[k++] = USART3_RX_BUF[a];
                }
                sscanf(fina_data1, "%d", &finaldata1); // 字符串转int
                sscanf(fina_data2, "%d", &finaldata2); // 字符串转int
                Delay_Ms(10);
                u1_printf("距离值=%dmm,回光量=%d\r\n", finaldata1, finaldata2); // print用串口2，串口1用来和激光模块通讯
                DIST = finaldata1 * 1.0 / 10;
                for (x = 0; x < j; x++) {
                    fina_data1[x] = 0;
                    fina_data2[x] = 0;
                }
                uflag      = 0;
                seri_count = 0;
                j          = 0;
                k          = 0;
            }
        }
    }
}
/*-------------------------------------------------*/
/*函数名：DMA1通道2中断服务函数                      */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void DMA1_Channel7_IRQHandler(void)
{
    if (DMA_GetITStatus(DMA1_IT_TC7) != RESET) { // 如果DMA1_IT_TC2置位，表示DMA1通道7发送完成中断，进入if
        DMA_ClearITPendingBit(DMA1_IT_TC7);      // 清除DMA1通道2 发送完成中断标志
        DMA_Cmd(DMA1_Channel7, DISABLE);         // 关闭DMA1通道2
        DMA_flag = 0;                            // 标志位清除 空闲状态
    }
}
/*-------------------------------------------------*/
/*函数名：定时器3中断服务函数                      */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void TIM3_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) { // 如果TIM_IT_Update置位，表示TIM3溢出中断，进入if
        switch (Ping_flag) {                             // 判断Ping_flag的状态
            case 0:                                      // 如果Ping_flag等于0，表示正常状态，发送Ping报文
                MQTT_PingREQ();                          // 添加Ping报文到发送缓冲区
                break;
            case 1:               // 如果Ping_flag等于1，说明上一次发送到的ping报文，没有收到服务器回复，所以1没有被清除为0，可能是连接异常，我们要启动快速ping模式
                TIM3_ENABLE_2S(); // 我们将定时器6设置为2s定时,快速发送Ping报文
                MQTT_PingREQ();   // 添加Ping报文到发送缓冲区
                break;
            case 2:             // 如果Ping_flag等于2，说明还没有收到服务器回复
            case 3:             // 如果Ping_flag等于3，说明还没有收到服务器回复
            case 4:             // 如果Ping_flag等于4，说明还没有收到服务器回复
                MQTT_PingREQ(); // 添加Ping报文到发送缓冲区
                break;
            case 5:                     // 如果Ping_flag等于5，说明我们发送了多次ping，均无回复，应该是连接有问题，我们重启连接
                Connect_flag = 0;       // 连接状态置0，表示断开，没连上服务器
                TIM_Cmd(TIM3, DISABLE); // 关TIM3
                break;
        }
        Ping_flag++;                                // Ping_flag自增1，表示又发送了一次ping，期待服务器的回复
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update); // 清除TIM3溢出中断标志
    }
}
/*-------------------------------------------------*/
/*函数名： EXTI9_5中断服务函数                      */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void EXTI9_5_IRQHandler(void)
{
    u8 laser_on[5]      = {'i', 'L', 'D', ':', '1'};
    u8 laser_off[5]     = {'i', 'L', 'D', ':', '0'};
    u8 laser_measure[3] = {'i', 'S', 'M'};

    if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5) == 0) {
        Delay_Ms(10); // 消抖
        beep_on_100ms();
        STMFLASH_Read(0x8010000, &Dynamic_check_value, 1);
        Dynamic_check_value -= 1;
        if (Dynamic_check_value > Maximum_check_value / Step_size)
            Dynamic_check_value = Minimum_check_value / Step_size;
        if (Dynamic_check_value < Minimum_check_value / Step_size)
            Dynamic_check_value = Maximum_check_value / Step_size;
        STMFLASH_Write(0x8010000, &Dynamic_check_value, 1);
        // TEST=Dynamic_check_value*Step_size*1.0;
        Usart_SendArray(USART3, laser_on, 5);
        OLED_SHOW();
        u1_printf("发生外部中断1\r\n");
    }
    EXTI_ClearITPendingBit(EXTI_Line5); // 中断线

    if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6) == 0) {
        Delay_Ms(10); // 消抖
        beep_on_100ms();
        STMFLASH_Read(0x8010000, &Dynamic_check_value, 1);
        Dynamic_check_value += 1;
        if (Dynamic_check_value > Maximum_check_value / Step_size)
            Dynamic_check_value = Minimum_check_value / Step_size;
        if (Dynamic_check_value < Minimum_check_value / Step_size)
            Dynamic_check_value = Maximum_check_value / Step_size;
        STMFLASH_Write(0x8010000, &Dynamic_check_value, 1);
        // TEST=Dynamic_check_value*Step_size*1.0;
        Usart_SendArray(USART3, laser_off, 5);
        OLED_SHOW();
        u1_printf("发生外部中断2\r\n");
    }
    EXTI_ClearITPendingBit(EXTI_Line6); // 中断线

    if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_7) == 0) {
        Delay_Ms(10); // 消抖
        beep_on_100ms();
        // flag = !flag;
        Usart_SendArray(USART3, laser_measure, 3);
        // if (flag) {
        //     OLED_Display_Off(); // Turn_off_OLED();
        // } else {
        //     OLED_Display_On(); // OLED_Init();
        // }
        // if (!flag) {
        //     OLED_SHOW();
        // }
        // if (!flag && result == 0) {
        //     OLED_Clear();
        //     OLED_ShowCHinese(0, 3, 10);
        //     OLED_ShowCHinese(18, 3, 11);
        //     OLED_ShowCHinese(36, 3, 12);
        //     OLED_ShowCHinese(54, 3, 13);
        //     OLED_ShowCHinese(72, 3, 14);
        //     OLED_ShowCHinese(90, 3, 15);
        //     OLED_ShowString(108, 3, "!");
        // }
        OLED_SHOW();
        u1_printf("发生外部中断3\r\n");
    }

    EXTI_ClearITPendingBit(EXTI_Line7); // 中断线
}
/*-------------------------------------------------*/
/*函数名：定时器2中断服务函数                      */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) { // 如果TIM_IT_Update置位，表示TIM2溢出中断，进入if
        SystemTimer++;                                   // 全局计时的变量+1,表示过去了1秒钟
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);      // 清除TIM2溢出中断标志
    }
}
/*-------------------------------------------------*/
/*函数名：不可屏蔽中断处理函数                     */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void NMI_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：硬件出错后进入的中断处理函数             */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void HardFault_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：内存管理中断处理函数                     */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void MemManage_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：预取指失败，存储器访问失败中断处理函数   */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void BusFault_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：未定义的指令或非法状态处理函数           */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void UsageFault_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：软中断，SWI 指令调用的处理函数           */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void SVC_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：调试监控器处理函数                       */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void DebugMon_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：可挂起的系统服务处理函数                 */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void PendSV_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：SysTic系统嘀嗒定时器处理函数             */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void SysTick_Handler(void)
{
}
